function define_parameters(target_values, bernstein_degree, sampling_points, timesteps=24)
    # time_steps = length(target_values)
    T = 1:timesteps
    B = 0:bernstein_degree
    S = 0:sampling_points
    bernstein_curves = zeros(bernstein_degree+1, sampling_points+1)
    target_values_expanded = zeros(sampling_points+1, timesteps)
    for s in S
        for b in B
            bernstein_curves[b+1, s+1] = get_bernstein_val(bernstein_degree, b, s/sampling_points)
        end
        for t in T
            target_values_expanded[s+1, t] = target_values[t]
        end
    end

    data = Dict(
        "bernstein_degree" => bernstein_degree,
        "bernstein_curves" => bernstein_curves,
        "target_values" => target_values_expanded,
        "B" => B,
        "S" => S,
        "T" => T
    )
    return data
end


function define_problem(parameters, cont_constraints=true)
    B = parameters["B"]
    T = parameters["T"]
    S = parameters["S"]
    bernstein_degree = parameters["bernstein_degree"]
    
    model = Model()
    set_optimizer(model, Ipopt.Optimizer)

    @variable(model, weights[b in B, t in T] â‰¥ 0)
    @variable(model, deviation[s in S, t in T])

    @constraint(model, deviation_summation[s in S, t in T], deviation[s, t] == sum(parameters["bernstein_curves"][b+1, s+1] * weights[b, t] for b in B) - parameters["target_values"][s+1, t])
    if cont_constraints
        @constraint(model, continuity_constraint1[t in T[1:end-1]], weights[bernstein_degree, t] == weights[0, t+1])
        @constraint(model, continuity_constraint2[t in T[1:end-1]], weights[bernstein_degree, t] - weights[bernstein_degree-1, t] == weights[1, t+1] - weights[0, t+1])
    end
    
    @objective(model, Min, sum(deviation[s, t]^2 for s in S for t in T))
    optimize!(model)

    weights = value.(weights)
    df = dense_array_to_df(weights)
    
    # df = get_converted_df_separated_timesteps(weights, S[end])
    converted_list = get_converted_list(df, S[end])
    # display(plot(converted_list))

    # plot_all_columns_df(df)

    # print(model)
    return df

end

function get_converted_list(weights_df, sampling_points)
    bernstein_degree = length(weights_df[:,1])-1
    time_steps = length(weights_df[1, :])
    converted_list = zeros(time_steps * sampling_points+1)

    for b in 0:bernstein_degree
        converted_list[1] += get_bernstein_val(bernstein_degree, b, 0) * weights_df[b+1, 1]        
        for t in 1:time_steps
            for s in 1:sampling_points
                # println((t-1)*sampling_points+s+1)
                converted_list[(t-1)*sampling_points+s+1] += get_bernstein_val(bernstein_degree, b, s/sampling_points) * weights_df[b+1, t]
            end
        end
    end
    a = 3
    return converted_list
end


function get_converted_df_separated_timesteps(weights, sampling_points)
    bernstein_degree = length(weights[:,1])-1
    time_steps = length(weights[0, :])
    df = DataFrame()
    for t in 1:time_steps
        # array = zeros(time_steps * sampling_points+1)
        array = fill(NaN, time_steps * sampling_points+1)
        for s in 0:sampling_points
            array[(t-1) * sampling_points+s+1] = 0
            for b in 0:bernstein_degree
                array[(t-1) * sampling_points+s+1] += get_bernstein_val(bernstein_degree, b, s/sampling_points) * weights[b, t]
            end
        end
        df[!, "$t"] = array
        # empty_df.t = array
        # hcat!(empty_df, new_df)
    end
    return df
end